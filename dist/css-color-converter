#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_node_path = __toESM(require("node:path"));

// src/rbgHex.js
var toHex = (red, green, blue, alpha) => (blue | green << 8 | red << 16 | 1 << 24).toString(16).slice(1) + alpha;
function rgbHex(red, green, blue, alpha) {
  let isPercent = (red + (alpha || "")).toString().includes("%");
  if (typeof red === "string" && !green) {
    const parsed = parseCssRgbString(red);
    if (!parsed) {
      throw new TypeError("Invalid or unsupported color format.");
    }
    isPercent = false;
    [red, green, blue, alpha] = parsed;
  } else if (alpha !== void 0) {
    alpha = Number.parseFloat(alpha);
  }
  if (typeof red !== "number" || typeof green !== "number" || typeof blue !== "number" || red > 255 || green > 255 || blue > 255) {
    throw new TypeError("Expected three numbers below 256");
  }
  if (typeof alpha === "number") {
    if (!isPercent && alpha >= 0 && alpha <= 1) {
      alpha = Math.round(255 * alpha);
    } else if (isPercent && alpha >= 0 && alpha <= 100) {
      alpha = Math.round(255 * alpha / 100);
    } else {
      throw new TypeError(`Expected alpha value (${alpha}) as a fraction or percentage`);
    }
    alpha = (alpha | 1 << 8).toString(16).slice(1);
  } else {
    alpha = "";
  }
  return toHex(red, green, blue, alpha);
}
var parseCssRgbString = (input) => {
  const parts = input.replace(/rgba?\(([^)]+)\)/, "$1").split(/[,\s/]+/).filter(Boolean);
  if (parts.length < 3) {
    return;
  }
  const parseValue = (value, max) => {
    value = value.trim();
    if (value.endsWith("%")) {
      return Math.min(Number.parseFloat(value) * max / 100, max);
    }
    return Math.min(Number.parseFloat(value), max);
  };
  const red = parseValue(parts[0], 255);
  const green = parseValue(parts[1], 255);
  const blue = parseValue(parts[2], 255);
  let alpha;
  if (parts.length === 4) {
    alpha = parseValue(parts[3], 1);
  }
  return [red, green, blue, alpha];
};

// src/css.ts
var processCss = (fileContents, convertToHex = false) => {
  const regex = /--(.*):.*(#[\da-fA-F]{3,8}|rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\)|rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s\d(.\d)*\));/g;
  function extractCSSVariables(str) {
    const matches = [];
    let match;
    while ((match = regex.exec(str)) !== null) {
      let color = match[2].trim();
      if (convertToHex && color.startsWith("rgb") || color.startsWith("rgba") && !color.endsWith(")")) {
        color = `#${rgbHex(color)}`;
      }
      matches.push({
        variable: match[1].trim(),
        color
      });
    }
    return matches;
  }
  const extractedVariables = extractCSSVariables(fileContents);
  return extractedVariables;
};

// src/index.ts
var import_node_process = require("node:process");
var import_node_fs = __toESM(require("node:fs"));

// src/util.ts
var kebabCaseToCamelCase = (str) => {
  return str.replace(/-./g, (x) => x.toUpperCase()[1]);
};
var outputKvPair = (res2) => res2.flat().reduce((acc, { variable, color }) => {
  acc[variable] = color;
  return acc;
}, {});
var kvPairToJsonString = (kvPair) => JSON.stringify(kvPair, null, 4);
var kvPairToTsString = (kvPair) => Object.entries(kvPair).map(
  ([key, value]) => `export const ${kebabCaseToCamelCase(key)} = "${value}";`
).join("\n");

// src/index.ts
if (import_node_process.argv.length < 4) {
  console.error("Please provide an output directory and a directory for CSS/LESS/SCSS files");
  (0, import_node_process.exit)(1);
}
var outputDir = import_node_process.argv[2];
var dir = import_node_process.argv[3];
var files = import_node_fs.default.readdirSync(dir);
var contents = files.filter((f) => f.endsWith(".css")).map((file) => import_node_fs.default.readFileSync(import_node_path.default.join(dir, file), "utf-8"));
var res = [];
for (const content of contents) {
  const toHex2 = import_node_process.argv.includes("--hex");
  res.push(processCss(content, toHex2));
}
var output = import_node_process.argv.includes("--json") ? "json" : "ts";
var outputKv = outputKvPair(res);
if (output === "json") {
  import_node_fs.default.writeFileSync(import_node_path.default.join(outputDir, "colors.json"), kvPairToJsonString(outputKv));
} else {
  import_node_fs.default.writeFileSync(import_node_path.default.join(outputDir, "colors.ts"), kvPairToTsString(outputKv));
}
